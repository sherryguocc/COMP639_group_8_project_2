from APP import getCursor
import json
from datetime import datetime
import re



class Calendar:
    def __init__(self, venueID, startDate, startTime, endDate, endTime, status, bookingID):
        # Constructor for the Calendar class.
        self.__calendarID = None  # Set calendarID to None (or omit it) since it's autogenerated
        self.__venueID = venueID
        self.__startDate = startDate
        self.__startTime = startTime
        self.__endDate = endDate
        self.__endTime = endTime
        self.__status = status
        self.__bookingID = bookingID

    # Property getters and setters for various attributes.
    # These allow controlled access to the private attributes.

    @property
    def calendarID(self):
        return self.__calendarID

    @property
    def venueID(self):
        return self.__venueID

    @venueID.setter
    def venueID(self, number):
        self.__venueID = number

    @property
    def startDate(self):
        return self.__startDate

    @startDate.setter
    def startDate(self, datevalue):
        self.__startDate = datevalue

    @property
    def startTime(self):
        return self.__startTime

    @startTime.setter
    def startTime(self, timevalue):
        self.__startTime = timevalue

    @property
    def endDate(self):
        return self.__endDate

    @endDate.setter
    def endDate(self, datevalue):
        self.__endDate = datevalue

    @property
    def endTime(self):
        return self.__endTime

    @endTime.setter
    def endTime(self, timevalue):
        self.__endTime = timevalue

    @property
    def status(self):
        return self.__status

    @status.setter
    def status(self, value):
        self.__status = value
    
    @property
    def bookingID(self):
        return self.__bookingID

    @bookingID.setter
    def bookingID(self, number):
        self.__bookingID = number

    @staticmethod
    def fetch_calendar_data(venue_id):
        connection = getCursor()
        calendar_query = "SELECT * FROM calendar WHERE venueID = %s"
        connection.execute(calendar_query, (venue_id,))
        rows = connection.fetchall()

        calendar_data = []

        for row in rows:
            entry = {
                "calendar_id": row[0],
                "start_date": Calendar.extract_date_as_int(row[2]),
                "start_time": int(row[3].total_seconds()),
                "end_date": Calendar.extract_date_as_int(row[4]),
                "end_time": int(row[5].total_seconds()),
                "status": row[6],
            }
            calendar_data.append(entry)

        return calendar_data
    
    @staticmethod
    def extract_date_as_int(date_obj):
            # Convert date object to string
            date_str = date_obj.strftime('%Y-%m-%d')

            # Use regular expressions to extract the numeric part of the date
            matches = re.findall(r'\d+', date_str)

            # Combine the extracted numeric parts into a string
            result = ''.join(matches)

            # Convert the result to an integer
            return int(result)
    
    def validate_and_insert(self):
        start_datetime = datetime.strptime(self.startDate + " " + self.startTime, '%Y-%m-%d %H:%M:%S')
        end_datetime = datetime.strptime(self.endDate + " " + self.endTime, '%Y-%m-%d %H:%M:%S')

        current_datetime = datetime.now()

        if start_datetime >= end_datetime:
            return False, 'Start date and time must be earlier than end date and time.'
        elif start_datetime.date() == end_datetime.date() and self.startTime >= self.endTime:
            return False, 'Start time must be earlier than end time when start and end dates are the same.'
        if start_datetime < current_datetime:
            return False, 'Start date and time cannot be earlier than the current date and time.'

        connection = getCursor()
        overlap_query = """
            SELECT COUNT(*) FROM calendar
            WHERE venueID = %s
            AND (
                (startDate < %s AND endDate > %s)
                OR (startDate = %s AND startTime < %s)
                OR (endDate = %s AND endTime > %s)
            )
        """
        connection.execute(overlap_query, (self.venueID, end_datetime, start_datetime, self.startDate, self.startTime, self.endDate, self.endTime))
        overlap = connection.fetchone()
        overlap_count = overlap[0]

        if overlap_count > 0:
            return False, 'Cannot add the calendar entry because it overlaps with an existing record.'

        insert_query = """
            INSERT INTO calendar (venueID, startDate, startTime, endDate, endTime, status, bookingID)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """

        values = (self.venueID, self.startDate, self.startTime, self.endDate, self.endTime, self.status, self.bookingID)

        # If bookingID is None, insert without the bookingID column and value
        if self.bookingID is None:
            insert_query = """
                INSERT INTO calendar (venueID, startDate, startTime, endDate, endTime, status)
                VALUES (%s, %s, %s, %s, %s, %s)
            """
            values = (self.venueID, self.startDate, self.startTime, self.endDate, self.endTime, self.status)

        connection.execute(insert_query, values)
        
        return True, 'Venue calendar updated successfully!'
    
    @staticmethod
    def insert_booked_calendar(booking_id):
        status = "Booked"
        connection = getCursor()

        # First, fetch the venue_id associated with the given booking_id from the venueorder table.
        fetch_venue_query = "SELECT venueorder.venueID FROM venueorder WHERE venueorder.bookingID = %s"
        connection.execute(fetch_venue_query, (booking_id,))
        venue_row = connection.fetchone()
        
        if venue_row:
            venue_id = venue_row[0]

            # Fetch booking information
            fetch_booking_information_query = "SELECT * FROM booking WHERE  booking.bookingID  = %s"
            connection.execute(fetch_booking_information_query, (booking_id,))
            booking_info = connection.fetchone()

            if booking_info:
                start_date = booking_info[6]
                start_time = booking_info[7]
                end_date = booking_info[8]
                end_time = booking_info[9]

                # Calendar insert validation
                overlap_query = """
                    SELECT COUNT(*) FROM calendar
                    WHERE venueID = %s
                    AND (
                        (startDate < %s AND endDate > %s)
                        OR (startDate = %s AND startTime < %s)
                        OR (endDate = %s AND endTime > %s)
                    )
                    AND (status = 'available' OR startDate > %s OR endDate < %s)
                """
                connection.execute(overlap_query, (venue_id, end_date, start_date, start_date, start_time, end_date, end_time, end_date, start_date))
                overlap = connection.fetchone()
                overlap_count = overlap[0]

                if overlap_count == 0:
                    new_calendar_entry = Calendar(venue_id, str(start_date), str(start_time), str(end_date), str(end_time), status, booking_id)
                    result, message = new_calendar_entry.validate_and_insert()
                    if result:
                        return message
                    else:
                        return "Failed to insert a calendar entry: " + message, False
                else:
                    return "Cannot add the calendar entry because it overlaps with an existing record or the status is not 'available'.", False
            else:
                return "Booking information not found for the given booking ID.", False
        else:
            return "No venue found for the given booking ID.", False
        
    @staticmethod
    def delete_calendar_entry(booking_id):
        connection = getCursor()

        # Fetch the venue_id associated with the given booking_id from the venueorder table.
        fetch_venue_query = "SELECT venueorder.venueID FROM venueorder WHERE venueorder.bookingID =  %s"
        connection.execute(fetch_venue_query, (booking_id,))
        venue_row = connection.fetchone()

        if venue_row:
            venue_id = venue_row[0]

            # Delete the calendar entry associated with the booking_id
            delete_calendar_query = "DELETE FROM calendar WHERE calendar.venueID = %s AND calendar.bookingID = %s"
            connection.execute(delete_calendar_query, (venue_id, booking_id))

            return "Calendar entry deleted successfully."

    @staticmethod
    def validate_before_booking(venueID, startDate, endDate):
        connection = getCursor()
        check_overlap_query = """SELECT COUNT(*) FROM calendar WHERE venueID = %s
                                                                            AND 
                                                                            (startDate < %s AND endDate > %s)
                                                                            AND 
                                                                            status NOT IN ('Available');"""
        connection.execute(check_overlap_query, (venueID, endDate, startDate))
        overlap_count = connection.fetchone()[0]
        if overlap_count > 0: 
            return False
        return True
    
    @staticmethod
    def update_canlendar_if_venue_change (venueID, bookingID):
        connection = getCursor()
        update = """UPDATE calendar SET venueID = %s WHERE calendar.bookingID = %s;"""
        connection.execute(update, (venueID, bookingID))
    
    @staticmethod
    def delete_calendar_due_to_booking(bookingID):
        connection = getCursor()
        delete = """DELETE FROM calendar WHERE calendar.bookingID = %s;"""
        connection.execute(delete, (bookingID,))

        